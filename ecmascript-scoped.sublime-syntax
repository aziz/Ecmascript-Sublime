%YAML 1.2
---
name: Ecmascript Scoped
file_extensions: [ js, es, es6 ]
scope: source.es

# This is a special variation that takes a very different approach. In the
# normal ES Sublime definition, we take great care to avoid depth on the context
# stack, because a syntax error could cause a cascade of mis-scoping that we’d
# prefer to finesse our way out of. Here we use the context stack as intended,
# which will lead to some very interesting effects. Specifically, it enables us
# to create themes that highlight on *depth of scope* (that is, JS scope)...

# This is really just an experiment right now, and as part of the experiment, I
# have used non-standard scope naming. Instead of long hierarchical strings, it
# leverages the natural hierarchy so that scopes can be targeted ‘organically’.

# In other words, you would not target this:
#  `punctuation.definition.comment`
#
# But rather:
#  `comment delimiter`
#
# If this works out, I wonder if we couldn’t begin developing new conventions
# that really take advantage of this better syntax tool...?
#
# Below, matches marked NEWLINE ALERT signal cases where sublime-syntax is not
# enough to resolve ambiguities if a newline is found in an unfortunate place.

variables:

# CHARACTER CLASSES ############################################################

  IDSTARTOTHER: '℘℮゛゜'
  IDSTART: '\p{L}\p{Nl}{{IDSTARTOTHER}}'
  IDCONTINUEOTHER: '··፩-፱᧚'
  IDCONTINUE: '{{IDSTART}}\p{Mn}\p{Mc}\p{Nd}\p{Pc}{{IDCONTINUEOTHER}}'

# BOUNDARY MATCHES #############################################################

  ANYTHING: '(?=[\S\s])'
  PROPSTART: '(?=\s*[\[''"\d\.]|\s+[{{IDSTART}}])'
  X: '(?=[^\$_‍‍{{IDCONTINUE}}]|$)'

# IDENTIFIERS ##################################################################

  UNICODEESCAPE: '\\u(?:\h{4}|\{\h+\})'
  RESERVED: 'await|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:e(?:bugger|fault|lete)|o)|e(?:lse|num|x(?:port|tends))|f(?:alse|inally|or|unction)|i(?:f|mp(?:lements|ort)|n(?:stanceof|terface)?)|Infinity|let|NaN|n(?:ew|ull)|p(?:ackage|r(?:ivate|otected)|ublic)|return|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y)|ypeof)|undefined|v(?:ar|oid)|w(?:hile|ith)|yield'
  IDPART:  '(?:[\$_‍‍{{IDCONTINUE}}]|{{UNICODEESCAPE}})*'
  IDCAP: '(\p{Lu}{{IDPART}})'
  IDGEN: '([{{IDSTART}}]{{IDPART}})'
  IDPROP: '(?:{{IDCAP}}|{{IDGEN}})'
  ID: '(?!(?:{{RESERVED}})[^\$_‍‍{{IDCONTINUE}}])(?<![{{IDCONTINUE}}])(?:{{IDCAP}}|{{IDGEN}})'

################################################################################
################################################################################

contexts:

# ASSISTS ######################################################################

  ELSE-INVALID:
    - match: '{{IDGEN}}|.'
      scope: invalid

  ELSE-POP:
    - match: '{{ANYTHING}}'
      pop: true

  NO-LINEBREAK-HERE:
    # Pop on newline or semicolon; else invalid
    - match: '$'
      pop: true
    - match: ';'
      scope: terminator
      pop: true
    # This takes care of cases where the continuation is legal because of scope
    # termination.
    - match: '(?=\})'
      pop: true
    - include: ELSE-INVALID

  LINEBREAK-HERE:
    # Pop on semicolon; else invalid. But, if a newline is encountered first,
    # pop on semicolon, or else just pop.
    - match: ';'
      scope: terminator
      pop: true
    - match: '$'
      set:
        - match: ';'
          scope: terminator
          pop: true
        - include: ELSE-POP
    - include: ELSE-INVALID

# ENTRY ########################################################################

  main:
    - meta_include_prototype: false
    - match: '^\#\!.*'
      scope: directive.shebang
      push: MODULE
    - match: '{{ANYTHING}}'
      push: MODULE

# PROTOTYPE ####################################################################

  prototype:
    - match: '\s+'
    - include: COMMENT

################################################################################
################################################################################

# COMMENT ######################################################################

  COMMENT:
    - include: COMMENT.BLOCK
    - include: COMMENT.LINE

  COMMENT.BLOCK:
    - match: '\/\*'
      scope: delim
      push:
        - meta_scope: comment
        - match: '\*\/'
          scope: delim
          pop: true

  COMMENT.LINE:
    - match: '\/\/'
      scope: delim
      push:
        - meta_scope: comment
        - match: '$'
          pop: true

# EXPRESSION ###################################################################

  EXPRESSION.entry:
    - match: '{{ANYTHING}}'
      set: [ EXPRESSION.exit, EXPRESSION.ASS.entry ]

  EXPRESSION.exit:
    - match: ','
      scope: operator.comma
      push: EXPRESSION.ASS.entry
    - include: ELSE-POP

  EXPRESSION.ASS.entry:
    - include: EXPRESSION.ASS.common
    - include: ELSE-INVALID

  EXPRESSION.ASS.common:
    # Simpler, unambiguous token matches first:
    - include: EXPRESSION.UNARY
    - include: EXPRESSION.CLASS
    - include: EXPRESSION.FUNCTION
    - include: EXPRESSION.DO
    - include: EXPRESSION.CONSTANT
    - include: EXPRESSION.LITERAL.REGEXP
    # Bracket-initialized
    - include: EXPRESSION.COMPREHENSION.ARRAY
    - include: EXPRESSION.BINDING.ARRAY
    - include: EXPRESSION.LITERAL.ARRAY
    # Brace-initialized
    - include: EXPRESSION.BINDING.OBJECT
    - include: EXPRESSION.LITERAL.OBJECT
    # Paren-initialized
    - include: EXPRESSION.FUNCTION.ARROW
    - include: EXPRESSION.COMPREHENSION.GENERATOR
    - include: EXPRESSION.PARENTHETICAL
    # Open-ended
    - include: EXPRESSION.REFERENCE

  # Four exits (plus one special case): these alternate exit cases (and note,
  # each is inclusive of its predecessors) are our half-assed way of following,
  # to a limited extent, some of the grammatical constraints of expression
  # formation. Since the grammatical designation of an expression (component) is
  # generally out of reach for us with linear matches, the best we can do is say
  # ‘the following are plausible continuations after X was encountered’. Though
  # it is hardly strict, and will permit plenty of malformed constructs that
  # ought to be detectable at this level, it is adequate for ensuring
  # unambiguous matching generally and reducing the number of nonsensical match
  # attempts on exiting various contexts.

  # OPERABLE
  # The AE thus far is not accessible, invocable, or assignable. This, on its
  # own, occurs only after postfix operators, undefined and null. (Though,
  # technically, assigning to undefined will not throw, I am willing to collect
  # that here as it is nonsensical legacy pollution from when undefined was
  # still a redefinable native variable; plus, accessing it is an error, so to
  # support this unusual and useless case would necessitate a totally different
  # exit structure.)
  EXPRESSION.ASS.exit.1:
    - match: '\?'
      scope: operator.logical
      set:
        - - include: EXPRESSION.ASS.entry
        - - match: ':'
            scope: operator.logical
            pop: true
          - include: ELSE-INVALID
        - - include: EXPRESSION.ASS.entry
    - match: '(?:[\+\-\/%]|\*{2})(?!=)'
      scope: operator.arithmetical
      set: EXPRESSION.ASS.entry
    # This special series of lookaheads is one of the (imperfect) approaches we
    # need to employ to prevent method decorator expressions from eating the
    # method itself. In this case, the issue is that the previously unambiguous
    # generator star, which can prefix a method name, could as easily be an
    # infix multiplication operator. The checks are:
    # 1. that it is not an arithmetical assignment
    # 2. that it is not a generator star with a double-quoted method name
    # 3. that it is not a generator star with a single-quoted method name
    # 4. that it is not a generator star with a computed method name
    # 5. that it is not a generator star with a literal method name
    # All of these checks can easily fail, irrecoverably, if a linebreak occurs
    # in an unfortunate position; and in the case of a computed property, it
    # will also fail if the accessor expression includes brackets; and in the
    # case of a regular method name, it is both extra sensitive to line breaks
    # and fails if the arguments contain parens (in default values). Finally,
    # this does not account for numeric literal property names.
    - match: >-
        (?x)
          \*
          (?! [=\*])
          (?! \s* " [^"]+ " \s* \( )
          (?! \s* '' [^'']+ '' \s* \( )
          (?! \s* \[ [^\]]+ \] \s* \( )
          (?! \s* {{IDGEN}} \s* \([^)]*\) \s* \{)
      scope: operator.arithmetical
      set: EXPRESSION.ASS.entry
    - match: '[!=]==?|[<>]=|in(?:stanceof)?{{X}}'
      scope: operator.relational
      set: EXPRESSION.ASS.entry
    - match: '&&|\|\|(?!=)'
      scope: operator.logical
      set: EXPRESSION.ASS.entry
    - match: '(?:[&\|\^]|<<|>>>?)(?!=)'
      scope: operator.bitwise
      set: EXPRESSION.ASS.entry
    # The bind operator is one of a number of cases where, although the grammar
    # is quite lucid, we leave things more open ended than they are in reality
    # for the sake of reducing the complexity of the grammar (and I am unsure if
    # it is even possible to model expression components like ‘NewExpression’ in
    # sublime-syntax with much success).
    - match: '::'
      scope: operator.evaluative
      set: EXPRESSION.ASS.entry
    - include: ELSE-POP

  # ACCESSIBLE, OPERABLE
  # The AE thus far is not invocable or assignable. This, on its own, occurs
  # after constants and literals.
  EXPRESSION.ASS.exit.2:
    - match: '\.'
      scope: operator.accessor
      set:
        - match: 'prototype{{X}}'
          scope: property prototype
          set: EXPRESSION.ASS.exit.4
        - match: '__proto__{{X}}'
          scope: property proto
          set: EXPRESSION.ASS.exit.4
        # We attempt to capture invocation/instantiation here, and the call
        # scope will then be inclusive of the identifier. This can be broken
        # by linebreaks, though it will not otherwise be disruptive.
        - match: '{{IDPROP}}\s*(\()'
          captures:
            1: identifier.class
            2: identifier.general
            3: arguments delim
          set: [ EXPRESSION.ASS.exit.3, EXPRESSION.ARGUMENTS.entry ]
        - match: '{{IDPROP}}'
          scope: property
          captures:
            1: identifier.class
            2: identifier.general
          set: EXPRESSION.ASS.exit.4
        - include: ELSE-INVALID
    # Prevent decorator expressions from eating computed properties, hopefully.
    # This is a sloppy patch for a defect in the proposed grammar.
    - match: >-
        (?x) (?=
          \[
            [^\[\]]+
          \]
          \s* \( [^\)]* \) \s* \{
        )
      pop: true
    - match: '\['
      scope: delim
      set: [ EXPRESSION.ASS.exit.4, EXPRESSION.PROPERTY.COMPUTED.entry ]
    - include: EXPRESSION.ASS.exit.1

  # INVOCABLE, ACCESSIBLE, OPERABLE
  # That is, any value except an identifier or property reference. In reality,
  # it is of course unknown whether such expressions are truly invocable, only
  # that it cannot be ruled out.
  EXPRESSION.ASS.exit.3:
    - match: '\('
      scope: arguments delim
      set: [ EXPRESSION.ASS.exit.3, EXPRESSION.ARGUMENTS.entry ]
    - match: '`'
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.INTERPOLATED.entry ]
    - include: EXPRESSION.ASS.exit.2

  # ASSIGNABLE, INVOCABLE, ACCESSIBLE, OPERABLE
  # That is, identifiers, including properties
  EXPRESSION.ASS.exit.4:
    - match: '=(?!=)'
      scope: operator.assignment
      set: EXPRESSION.ASS.entry
    - match: '(?:[\+\-\/%]|\*{1,2})='
      scope: operator.assignment.arithmetical
      set: EXPRESSION.ASS.entry
    # This existed in Babel at one point, but I’m not sure if it stuck around
    - match: '\|\|='
      scope: operator.assignment.mallet
      set: EXPRESSION.ASS.entry
    - match: '(?:[&\^\|]|<<|>>>?)='
      scope: operator.assignment.bitwise
    # We match the newline here to ‘skip’ postfix ops in that case
    - match: '$'
      set: EXPRESSION.ASS.exit.3
    - match: '\+\+|\-\-'
      scope: operator.assignment.arithmetical.postfix
      set: EXPRESSION.ASS.exit.1
    - include: EXPRESSION.ASS.exit.3

  # SPECIAL: AMBIGUOUS OBJECT/ARRAY LITERAL TRAP
  # The AE thus far is as #2, but is conceivably the binding pattern of an
  # assignment with an obnoxiously placed linebreak
  EXPRESSION.ASS.exit.5:
    - match: '=(?!=)'
      scope: operator.assignment
    - include: EXPRESSION.ASS.exit.2

# EXPRESSION: BINDING PATTERNS #################################################

  EXPRESSION.BINDING.ARRAY:
    - match: '\[(?=(?<brackets>[^\[\]]|\[\g<brackets>*\])*\]\s*=[^=])'
      scope: delim
      set:
        - EXPRESSION.ASS.exit.4
        - EXPRESSION.BINDING.ARRAY.exit
        - EXPRESSION.BINDING.ARRAY.entry

  EXPRESSION.BINDING.ARRAY.entry:
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set:
        - EXPRESSION.BINDING.ARRAY.member
        - EXPRESSION.DEFAULT-ASSIGNMENT
    - match: '\.{3}'
      scope: keyword.rest
      set:
        - EXPRESSION.BINDING.ARRAY.terminus
        - EXPRESSION.BINDING.rest
    - match: '\['
      scope: delim
      set:
        - EXPRESSION.BINDING.ARRAY.member
        - EXPRESSION.BINDING.ARRAY.exit
        - EXPRESSION.BINDING.ARRAY.entry
    - match: '\{'
      scope: delim
      set:
        - EXPRESSION.BINDING.ARRAY.member
        - EXPRESSION.BINDING.OBJECT.exit
        - EXPRESSION.BINDING.OBJECT.entry
    - include: EXPRESSION.BINDING.ARRAY.member

  EXPRESSION.BINDING.ARRAY.exit:
    - meta_scope: pattern.array
    - include: ELSE-POP

  EXPRESSION.BINDING.ARRAY.member:
    - match: ','
      scope: separator.comma
      set:
        - EXPRESSION.BINDING.ARRAY.exit
        - EXPRESSION.BINDING.ARRAY.entry
    - include: EXPRESSION.BINDING.ARRAY.terminus

  EXPRESSION.BINDING.ARRAY.terminus:
    - match: '\]'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.BINDING.OBJECT:
    - match: '\{(?=(?<braces>[^\{\}]|\{\g<braces>*\})*\}\s*=[^=])'
      scope: delim
      set:
        - EXPRESSION.ASS.exit.4
        - EXPRESSION.BINDING.OBJECT.exit
        - EXPRESSION.BINDING.OBJECT.entry

  EXPRESSION.BINDING.OBJECT.entry:
    # ES7 destructured rest object (obj takes ownKeys not otherwise gobbled)
    - match: '\.{3}'
      scope: keyword.rest
      set:
        - EXPRESSION.BINDING.OBJECT.terminus
        - EXPRESSION.BINDING.rest
    - match: '(?=[\d\.])'
      set:
        - EXPRESSION.BINDING.OBJECT.member
        - EXPRESSION.BINDING.OBJECT.property
        - EXPRESSION.NUMBER.entry
    - match: ''''
      scope: delim
      set:
        - EXPRESSION.BINDING.OBJECT.member
        - EXPRESSION.BINDING.OBJECT.property
        - EXPRESSION.STRING.SINGLE.entry
    - match: '"'
      scope: delim
      set:
        - EXPRESSION.BINDING.OBJECT.member
        - EXPRESSION.BINDING.OBJECT.property
        - EXPRESSION.STRING.DOUBLE.entry
    - match: '\['
      scope: delim
      set:
        - - include: EXPRESSION.BINDING.OBJECT.member
        - - include: EXPRESSION.BINDING.OBJECT.property
        - - meta_scope: property.computed
          - match: '\]'
            scope: delim
            pop: true
          - include: ELSE-INVALID
        - - include: EXPRESSION.ASS.entry
    # Newline-sensitive: cannot be matched perfectly
    - match: '{{ID}}\s*(:)'
      scope: property.binding
      captures:
        3: separator.colon
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set:
        - EXPRESSION.BINDING.OBJECT.member
        - EXPRESSION.BINDING.OBJECT.colon-cleanse
    - include: EXPRESSION.BINDING.OBJECT.terminus

  EXPRESSION.BINDING.OBJECT.exit:
    - meta_scope: pattern.object
    - meta_include_prototype: false
    - include: COMMENT
    - include: ELSE-POP

  EXPRESSION.BINDING.OBJECT.colon-cleanse:
    # Recovery scope for the unmatchable sequence 'key\n:'
    - match: ':'
      scope: property.binding separator.colon
      set: EXPRESSION.BINDING.OBJECT.target
    - include: ELSE-POP

  EXPRESSION.BINDING.OBJECT.member:
    # A dangling comma in a non-empty property list is explicitly permitted, so
    # we don’t need to fuss much here.
    - match: ','
      scope: separator.comma
      set: EXPRESSION.BINDING.OBJECT.entry
    - include: EXPRESSION.BINDING.OBJECT.terminus

  EXPRESSION.BINDING.OBJECT.property:
    - meta_content_scope: property.binding
    - match: ':'
      scope: separator.colon
      set: EXPRESSION.BINDING.OBJECT.target
    - include: ELSE-INVALID

  EXPRESSION.BINDING.OBJECT.target:
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set: EXPRESSION.DEFAULT-ASSIGNMENT
    - match: '\['
      scope: delim
      set:
        - EXPRESSION.DEFAULT-ASSIGNMENT
        - EXPRESSION.BINDING.ARRAY.exit
        - EXPRESSION.BINDING.ARRAY.entry
    - match: '\{'
      scope: delim
      set:
        - EXPRESSION.DEFAULT-ASSIGNMENT
        - EXPRESSION.BINDING.OBJECT.exit
        - EXPRESSION.BINDING.OBJECT.entry
    - include: ELSE-INVALID

  EXPRESSION.BINDING.OBJECT.terminus:
    - match: '\}'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.BINDING.rest:
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      pop: true
    - include: ELSE-INVALID

# EXPRESSION: COMPREHENSIONS ###################################################

  # I haven’t been able to find a formal grammar for comprehensions that seems
  # to have *anything* to do with the implementation found in Babel. If you know
  # where this thing comes from, please point me towards the spec -- it’s tough
  # to work blind. Given the extent of its removal from anything I’ve turned up
  # regarding comprehensions on ES Discuss, I’ve begun to wonder if this ought
  # to be included at all in an ‘EcmaScript’ syntax definition -- even one that
  # is otherwise happy to include proposed features.

  # Babel permits linebreaks between the opening paren and its 'for'. As in many
  # other cases, the limitations of Sublime Syntax prevent us from recognizing
  # such a thing correctly at the outset.

  EXPRESSION.COMPREHENSION.ARRAY:
    - match: '(\[)\s*(for){{X}}'
      captures:
        1: delim
        2: keyword.for
      set:
        - EXPRESSION.ASS.exit.2
        - EXPRESSION.COMPREHENSION.ARRAY.exit
        - EXPRESSION.COMPREHENSION.entry

  EXPRESSION.COMPREHENSION.ARRAY.exit:
    - meta_scope: comprehension.array
    - match: '\]'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.COMPREHENSION.GENERATOR:
    - match: '(\()\s*(for){{X}}'
      captures:
        1: delim
        2: keyword.for
      set:
        - EXPRESSION.ASS.exit.2
        - EXPRESSION.COMPREHENSION.GENERATOR.exit
        - EXPRESSION.COMPREHENSION.entry

  EXPRESSION.COMPREHENSION.GENERATOR.exit:
    - meta_scope: comprehension.generator
    - match: '\)'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.COMPREHENSION.entry:
    - match: '\('
      scope: delim
      set:
        - match: '{{ID}}'
          capture:
            1: identifier.class
            2: identifier.general
          set:
            - match: 'of{{X}}'
              scope: keyword.of
              set:
                - - match: '\)'
                    scope: delim
                    set: EXPRESSION.COMPREHENSION.exit.1
                - - include: EXPRESSION.ASS.entry
            - include: ELSE-INVALID
        - include: ELSE-INVALID
    - include: ELSE-INVALID

  EXPRESSION.COMPREHENSION.exit.1:
    - match: 'for{{X}}'
      scope: keyword.for
      set: EXPRESSION.COMPREHENSION.entry
    - include: EXPRESSION.COMPREHENSION.exit.2

  EXPRESSION.COMPREHENSION.exit.2:
    - match: 'if{{X}}'
      scope: keyword.if
      set:
        - match: '\('
          scope: delim
          set:
            - - match: '\)'
                scope: delim
                set: EXPRESSION.COMPREHENSION.exit.2
            - - include: EXPRESSION.ASS.entry
        - include: ELSE-INVALID
    - include: EXPRESSION.ASS.entry

# EXPRESSION: CONSTANTS ########################################################

  EXPRESSION.CONSTANT:
    - match: '(?:NaN|Infinity){{X}}'
      scope: constant.numeric.abstract
      set: EXPRESSION.ASS.exit.2
    - match: '(?:true|false){{X}}'
      scope: constant.boolean
      set: EXPRESSION.ASS.exit.2
    - match: 'null{{X}}'
      scope: constant.null
      set: EXPRESSION.ASS.exit.1
    - match: 'undefined{{X}}'
      scope: constant.undefined
      set: EXPRESSION.ASS.exit.1
    - match: '(?=[\d\.])'
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.NUMBER.entry ]
    - match: "'"
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.SINGLE.entry ]
    - match: '"'
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.DOUBLE.entry ]
    - match: '`'
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.INTERPOLATED.entry ]

# EXPRESSION: FUNCTIONS, ETC ###################################################

  EXPRESSION.CLASS:
    - match: 'class{{X}}'
      scope: keyword.class
      set: [ EXPRESSION.ASS.exit.3, CLASS.exit, EXPRESSION.CLASS.entry ]
    - match: '@'
      scope: keyword.decorator
      set:
        - - include: EXPRESSION.CLASS
          - include: ELSE-INVALID
        - - meta_scope: decorator
          - include: ELSE-POP
        - - include: EXPRESSION.ASS.entry

  EXPRESSION.CLASS.entry:
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set: CLASS.super-or-body
    - include: CLASS.super-or-body

  EXPRESSION.DO:
    # The ES7 do expression is not actually a function, but behaves very much
    # like an IIFE in that it ‘expressionizes’ a scope closure and has a body
    # composed by a statement list.
    - match: 'do{{X}}'
      scope: keyword.do-expression
      set:
        - match: '\{'
          scope: delim
          push:
            # Could evaluate to anything but an assignable reference.
            - - include: EXPRESSION.ASS.exit.3
            - - meta_scope: scope.lexical block.do-expression
              - match: '\}'
                scope: delim
                pop: true
              - include: STATEMENTS
        - include: ELSE-INVALID

  EXPRESSION.FUNCTION:
    # Note that the grammar for async functions specifies no-line-terminator
    # between the keywords, so there is no ambiguity possible and no extra
    # lateral transition. The same is, unfortunately, not true of the generator
    # star, so a recovery context is required.
    - match: '(async)\s+(function){{X}}'
      captures:
        1: keyword.async
        2: keyword.function
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.ASYNC.exit
        - EXPRESSION.FUNCTION.entry.1
    - match: '(function)\s*(\*)'
      captures:
        1: keyword.function
        2: keyword.generator
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.GENERATOR.exit
        - EXPRESSION.FUNCTION.entry.1
    - match: 'function{{X}}'
      scope: keyword.function
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.FUNCTION.exit
        - EXPRESSION.FUNCTION.entry.2

  EXPRESSION.FUNCTION.entry.1:
    - include: EXPRESSION.FUNCTION.entry.common
    - include: EXPRESSION.FUNCTION.body

  EXPRESSION.FUNCTION.entry.2:
    # A recovery match for 'function\n*'. The function will remain miscoped at
    # the root, but otherwise matching can continue correctly.
    - match: '\*'
      scope: keyword.generator
      set: EXPRESSION.FUNCTION.entry.1
    - include: EXPRESSION.FUNCTION.entry.1

  EXPRESSION.FUNCTION.entry.3:
    # For method definitions
    - include: EXPRESSION.FUNCTION.entry.common
    - match: '\['
      scope: delim
      set:
        - EXPRESSION.FUNCTION.body
        - EXPRESSION.FUNCTION.name
        - EXPRESSION.PROPERTY.COMPUTED.entry
    - match: ''''
      scope: delim
      set:
        - EXPRESSION.FUNCTION.body
        - EXPRESSION.FUNCTION.name
        - EXPRESSION.STRING.SINGLE.entry
    - match: '"'
      scope: delim
      set:
        - EXPRESSION.FUNCTION.body
        - EXPRESSION.FUNCTION.name
        - EXPRESSION.STRING.DOUBLE.entry
    - match: '(?=[\d\.])'
      set:
        - EXPRESSION.FUNCTION.body
        - EXPRESSION.FUNCTION.name
        - EXPRESSION.NUMBER.entry
    - include: ELSE-INVALID

  EXPRESSION.FUNCTION.entry.common:
    # On its own, used in method productions
    - match: '{{ID}}'
      captures:
        1: name identifier.class
        2: name identifier.general
      set: EXPRESSION.FUNCTION.body

  EXPRESSION.FUNCTION.body:
    - match: '\('
      scope: delim
      set: 
        - - match: '\{'
            scope: delim
            set: FUNCTION.body.entry
          - include: ELSE-INVALID
        - - include: FUNCTION.PARAMETERS.exit
        - - include: FUNCTION.PARAMETERS.entry
    - include: ELSE-INVALID
  
  EXPRESSION.FUNCTION.name:
    - meta_scope: name
    - include: ELSE-POP

  EXPRESSION.FUNCTION.ACCESSOR.exit:
    - meta_scope: method.accessor
    - include: ELSE-POP

  EXPRESSION.FUNCTION.ARROW:
    # Note that, thankfully, a newline between params & the arrow is an error.
    # Therefore we do not need to do any funny dancing around to identify an
    # arrow function unambiguously.
    #
    # Match the open paren of an *upcoming* occurence’s params
    - match: '(?x) \( (?= (?<parens> [^\(\)] | \( \g<parens>* \) )* \)\s*=> )'
      scope: delim
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.FUNCTION.exit
        - EXPRESSION.FUNCTION.ARROW.arrow
        - FUNCTION.PARAMETERS.exit
        - FUNCTION.PARAMETERS.entry
    # Match a single unparenthetical parameter & its arrow
    - match: '{{ID}}\s*(=>)'
      captures:
        1: parameters identifier.class
        2: parameters identifier.general
        3: keyword.arrow
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.FUNCTION.exit
        - EXPRESSION.FUNCTION.ARROW.body
    # Match the open paren of an *upcoming* occurence’s params, async
    - match: '(?x) (async)\s* \( (?= (?<parens> [^\(\)] | \( \g<parens>* \) )* \)\s*=> )'
      scope: delim
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.ASYNC.exit
        - EXPRESSION.FUNCTION.ARROW.arrow
        - FUNCTION.PARAMETERS.exit
        - FUNCTION.PARAMETERS.entry
    # Match a single unparenthetical parameter & its arrow, async
    - match: '(async)\s+{{ID}}\s*(=>)'
      captures:
        1: keyword.async
        2: parameters identifier.class
        3: parameters identifier.general
        4: keyword.arrow
      set:
        - EXPRESSION.ASS.exit.3
        - FUNCTION.ASYNC.exit
        - EXPRESSION.FUNCTION.ARROW.body

  EXPRESSION.FUNCTION.ARROW.arrow:
    - match: '=>'
      scope: keyword.arrow
      set: EXPRESSION.FUNCTION.ARROW.body
    - include: ELSE-INVALID

  EXPRESSION.FUNCTION.ARROW.body:
    - match: '\{'
      scope: delim
      set: FUNCTION.body.entry
    - include: EXPRESSION.ASS.entry

  EXPRESSION.FUNCTION.GET.entry:
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set:
        - - match: '\('
            scope: parameters delim
            set:
              - match: '\)'
                scope: parameters delim
                set:
                  - match: '\{'
                    scope: delim
                    set: FUNCTION.body.entry
                  - include: ELSE-INVALID
              - include: ELSE-INVALID
          - include: ELSE-INVALID
    - include: ELSE-INVALID

  EXPRESSION.FUNCTION.METHOD.exit:
    - meta_scope: method
    - include: ELSE-POP

  EXPRESSION.FUNCTION.SET.entry:
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set:
        - match: '\('
          scope: parameters delim
          set:
            - - match: '\)'
                scope: parameters delim
                set:
                  - match: '\{'
                    scope: delim
                    set: FUNCTION.body.entry
                  - include: ELSE-INVALID
              - include: ELSE-INVALID
            - - match: '\{'
                scope: delim
                set:
                  - EXPRESSION.DEFAULT-ASSIGNMENT
                  - EXPRESSION.BINDING.OBJECT.exit
                  - EXPRESSION.BINDING.OBJECT.entry
              - match: '\['
                scope: delim
                set:
                  - EXPRESSION.DEFAULT-ASSIGNMENT
                  - EXPRESSION.BINDING.ARRAY.exit
                  - EXPRESSION.BINDING.ARRAY.entry
              - match: '{{ID}}'
                captures:
                  1: identifier.class
                  2: identifier.general
                set: EXPRESSION.DEFAULT-ASSIGNMENT
              - include: ELSE-INVALID
        - include: ELSE-INVALID
    - include: ELSE-INVALID

# EXPRESSION: LITERAL: ARRAY ###################################################

  EXPRESSION.LITERAL.ARRAY:
    - match: '\['
      scope: literal.array delim
      set:
        # A recovery case for the unmatchable sequence '[\nfor'
        - match: 'for{{X}}'
          scope: comprehension.array keyword.for
          set:
            - EXPRESSION.ASS.exit.2
            - EXPRESSION.COMPREHENSION.ARRAY.exit
            - EXPRESSION.COMPREHENSION.entry
        - match: '{{ANYTHING}}'
          set:
            - EXPRESSION.ASS.exit.5
            - EXPRESSION.LITERAL.ARRAY.exit
            - EXPRESSION.LITERAL.ARRAY.entry

  EXPRESSION.LITERAL.ARRAY.entry:
    - match: '\]'
      scope: delim
      pop: true
    - match: ','
      scope: separator.comma
    - match: '\.{3}'
      scope: keyword.spread
      set: [ EXPRESSION.LITERAL.ARRAY.member, EXPRESSION.ASS.entry ]
    - match: '{{ANYTHING}}'
      set: [ EXPRESSION.LITERAL.ARRAY.member, EXPRESSION.ASS.entry ]

  EXPRESSION.LITERAL.ARRAY.member:
    - match: ','
      scope: separator.comma
      set: EXPRESSION.LITERAL.ARRAY.entry
    - match: '\]'
      scope: delim
      pop: true

  EXPRESSION.LITERAL.ARRAY.exit:
    - meta_scope: literal.array
    - include: ELSE-POP

# EXPRESSION: LITERAL: OBJECT ##################################################

  EXPRESSION.LITERAL.OBJECT:
    - match: '\{'
      scope: delim
      set:
        - EXPRESSION.ASS.exit.5
        - EXPRESSION.LITERAL.OBJECT.exit
        - EXPRESSION.LITERAL.OBJECT.entry

  EXPRESSION.LITERAL.OBJECT.entry:
    # Unfortunately, while the syntax for class bodies and object literals has a
    # lot in common, we cannot avoid a fair amount of repetition in this case,
    # because we need to perform different disambiguations.
    - match: '\}'
      scope: delim
      pop: true
    - match: '\.{3}'
      scope: keyword.spread
      set: [ EXPRESSION.LITERAL.OBJECT.member, EXPRESSION.ASS.entry ]
    - match: '@'
      scope: keyword.decorator
      set:
        - - include: EXPRESSION.LITERAL.OBJECT.method
          # I’m not sure if property decoration is currently supported, but we
          # must treat it as if it is regardless because of 'prop\n('.
          - include: EXPRESSION.LITERAL.OBJECT.property
          - match: '@'
            scope: keyword.decorator
            set:
              - - meta_scope: decorator
                - include: ELSE-POP
              - - include: EXPRESSION.ASS.entry
          - include: ELSE-INVALID
        - - meta_scope: decorator
          - include: ELSE-POP
        - - include: EXPRESSION.ASS.entry
    - include: EXPRESSION.LITERAL.OBJECT.method
    - include: EXPRESSION.LITERAL.OBJECT.property
    - include: ELSE-INVALID

  EXPRESSION.LITERAL.OBJECT.member:
    - match: ','
      scope: separator.comma
      set: EXPRESSION.LITERAL.OBJECT.entry
    - match: '\}'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.LITERAL.OBJECT.method:
    # A generator method is straightforward (or would be, if not for decorators)
    - match: '\*'
      scope: keyword.generator
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.FUNCTION.METHOD.exit
        - FUNCTION.GENERATOR.exit
        - EXPRESSION.FUNCTION.entry.3
    # The next three, though simple keywords, require lookaheads here (unlike in
    # class bodies), because they can also be regular property names or they
    # could even be method names themselves.
    - match: 'async{{PROPSTART}}'
      scope: keyword.async
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.FUNCTION.METHOD.exit
        - FUNCTION.ASYNC.exit
        - EXPRESSION.FUNCTION.entry.3
    - match: 'get{{PROPSTART}}'
      scope: keyword.accessor.get
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.FUNCTION.ACCESSOR.exit
        - EXPRESSION.FUNCTION.GET.entry
    - match: 'set{{PROPSTART}}'
      scope: keyword.accessor.set
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.FUNCTION.ACCESSOR.exit
        - EXPRESSION.FUNCTION.SET.entry
    # We use pure lookaheads for computed, string and numeric method names.
    # Precision in the numeric match is not needed, as any string matching which
    # is not a valid number could not be valid as anything else, either.
    - match: >-
        (?x)
          (?=(?:
            \[(?<brackets>[^\[\]]|\[\g<brackets>*\])*\]|
            ''(?<squotes>[^'']|''\g<squotes>*'')*''|
            "(?<dquotes>[^"]|"\g<dquotes>*")*"|
            (?:0[BbOoXx])?[\d\.][\d\.e\+\-]*|
            {{ID}}
          )\s*\()
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.FUNCTION.METHOD.exit
        - EXPRESSION.FUNCTION.entry.3

  EXPRESSION.LITERAL.OBJECT.property:
    - match: '\['
      scope: delim
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.LITERAL.OBJECT.value
        - EXPRESSION.PROPERTY.COMPUTED.entry
    - match: ''''
      scope: delim
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.LITERAL.OBJECT.value
        - EXPRESSION.STRING.SINGLE.entry
    - match: '"'
      scope: delim
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.LITERAL.OBJECT.value
        - EXPRESSION.STRING.DOUBLE.entry
    - match: '(?=[\d\.])'
      set:
        - EXPRESSION.LITERAL.OBJECT.member
        - EXPRESSION.LITERAL.OBJECT.value
        - EXPRESSION.NUMBER.entry
    - match: '{{ID}}'
      captures:
        1: property identifier.class
        2: property identifier.general
      set:
        - - include: EXPRESSION.LITERAL.OBJECT.member
        - - include: EXPRESSION.LITERAL.OBJECT.value.common
          - include: ELSE-POP

  EXPRESSION.LITERAL.OBJECT.value:
    - meta_scope: property
    - include: EXPRESSION.LITERAL.OBJECT.value.common
    - include: ELSE-INVALID

  EXPRESSION.LITERAL.OBJECT.value.common:
    - match: ':'
      scope: separator.colon
      set: EXPRESSION.ASS.entry
    # Recovery capture for methods in the form '{property}\n('
    - match: '(?=\()'
      set:
        - EXPRESSION.FUNCTION.METHOD.exit
        - EXPRESSION.FUNCTION.body

  EXPRESSION.LITERAL.OBJECT.exit:
    - meta_scope: literal.object
    - meta_include_prototype: false
    - include: COMMENT
    - include: ELSE-POP

# EXPRESSION: LITERAL: REGEXP ##################################################

  EXPRESSION.LITERAL.REGEXP:
    - match: '/(?![/\*])'
      scope: delim
      set:
        - EXPRESSION.ASS.exit.2
        - EXPRESSION.LITERAL.REGEXP.exit
        - EXPRESSION.LITERAL.REGEXP.entry

  EXPRESSION.LITERAL.REGEXP.entry:
    - match: '/'
      scope: delim
      set: EXPRESSION.LITERAL.REGEXP.flags
    # TODO

  EXPRESSION.LITERAL.REGEXP.exit:
    - meta_scope: literal.regexp
    - include: ELSE-POP

  EXPRESSION.LITERAL.REGEXP.flags:
    - match: >-
        (?x)
          (?:([giumy])
            (?:((?!\1)[giumy])
              (?:((?!\1|\2)[giumy])
                (?:((?!\1|\2|\3)[giumy])
                  (?:((?!\1|\2|\3|\4)[giumy])
                  )?
                )?
              )?
            )?
          )
      scope: flags
      pop: true
    - include: ELSE-POP

# EXPRESSION: PARENTHETICAL ####################################################

  EXPRESSION.PARENTHETICAL:
    - match: '\('
      scope: parenthetical-expression delim
      set:
        # A recovery case for the unmatchable sequence '(\nfor'
        - match: 'for{{X}}'
          scope: comprehension.generator keyword.for
          set:
            - EXPRESSION.ASS.exit.2
            - EXPRESSION.COMPREHENSION.GENERATOR.exit
            - EXPRESSION.COMPREHENSION.entry
        - match: '{{ANYTHING}}'
          set:
            # Since we really don’t know what’s gonna go on in here, we need to
            # exit in the most permissive way.
            - - include: EXPRESSION.ASS.exit.4
            - - meta_scope: parenthetical-expression
              - match: '\)'
                scope: delim
                pop: true
              - include: ELSE-INVALID
            - - include: EXPRESSION.entry
              - include: ELSE-INVALID

# EXPRESSION: REFERENCE ########################################################

  EXPRESSION.REFERENCE:
    # Though the new.target keyword can contain linebreaks, we don’t try to
    # recover from that; it’s simply too stupid.
    - match: 'new\s*\.\s*target'
      scope: reference.new-target
      set: EXPRESSION.ASS.exit.4
    # We could create a correct exit (one with the elements of 2 & 3 but without
    # those of exit 1); but this is sufficient.
    - match: 'super{{X}}'
      scope: reference.super
      set: EXPRESSION.ASS.exit.3
    - match: 'this{{X}}'
      scope: reference.this
      set: EXPRESSION.ASS.exit.4
    - match: >-
        (?x) (
          Array(?:Buffer)? | Boolean | Date | DataView |
          (?:Eval|Range|Reference|Syntax|Type|URI)?Error |
          Float(?:32|64)Array | Function | Int(?:8|16|32)Array |
          Number | Object | Promise | Proxy | Reflect | RegExp | String |
          Symbol | Uint(?:8(?:Clamped)?|16|32)Array | (?:Weak)?(?:Map|Set)
        ){{X}}
      scope: native identifier.class
      set: EXPRESSION.ASS.exit.4
    - match: >-
        (?x) (
          console | (?:de|en)codeURI(?:Component)? |
          eval | Intl | is(?:Finite|NaN) | JSON | Math | parse(?:Float|Int) |
          (?:set|clear)(?:Timeout|Interval|Immediate) | SIMD
        ){{X}}
      scope: native identifier.general
      set: EXPRESSION.ASS.exit.4
    - match: '{{ID}}\s*(\()'
      captures:
        1: identifier.class
        2: identifier.general
        3: arguments delim
      set: [ EXPRESSION.ASS.exit.3, EXPRESSION.ARGUMENTS.entry ]
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set: EXPRESSION.ASS.exit.4

# EXPRESSION: UNARY PREFIX OPERATORS ###########################################

  EXPRESSION.UNARY:
    # The prefix operators don’t cause any scope transitions. This is a rather
    # fuzzy zone since unary expressions prefixes must be followed by other
    # unary expressions; we cannot model this. Also, the prefix arithmetical
    # operators, as well as delete, are really only valid before unary
    # expressions that are ultimately references, but even the formal spec
    # doesn’t seem to model that fact at the grammar level. Finally note that
    # the :: operator in this form is technically a new production, entered from
    # LHS or CallExpression, though for our purposes this should do. The 'new'
    # keyword is technically followed only by MemberExpression. Yield * is the
    # only item here that is grammatically perfect out-of-the-box; yield is
    # okay, too, but needs special futzing because its AE is optional.
    - match: '(?:delete|typeof|void){{X}}|new(?!\.){{X}}|::'
      scope: operator.evaluative
    - match: '\+\+|\-\-'
      scope: operator.assignment.arithmetical.prefix
    - match: '[\+\-]'
      scope: numeric.sign
    - match: '!'
      scope: operator.logical
    - match: '~'
      scope: operator.bitwise
    - match: 'await{{X}}'
      scope: keyword.await
    - match: '(yield)\s*(\*)'
      captures:
        1: keyword.yield
        2: keyword.delegate
    - match: 'yield{{X}}'
      scope: keyword.yield
      set:
        - match: '$'
          pop: true
        - include: EXPRESSION.ASS.common
        - include: ELSE-POP

# EXPRESSION: SHARED COMPONENTS ################################################

  EXPRESSION.DEFAULT-ASSIGNMENT:
    - match: '=(?!=)'
      scope: operator.assignment.default
      set: EXPRESSION.ASS.entry
    - include: ELSE-POP

  EXPRESSION.ARGUMENTS.entry:
    - meta_scope: invocation
    - meta_content_scope: arguments
    - match: '\)'
      scope: arguments delim
      pop: true

  EXPRESSION.NUMBER.entry:
    # Can be entered from constant or may appear as an object literal key
    # Enterability (on lookahead) prevents the need for duplication
    - match: >-
        (?x)
          (?:
            0 (?: \. \d* )? |
            [1-9]\d* (?: \. \d* )? |
            \. \d+
          )
          ( [Ee] [\+\-]? \d+ )?
          {{X}}
      scope: constant.numeric.decimal
      captures:
        1: constant.numeric.exponent
      pop: true
    - match: '(0[Bb])[01]+'
      scope: constant.numeric.binary
      captures:
        1: constant.numeric.prefix
      pop: true
    - match: '(0[Oo])[0-7]+'
      scope: constant.numeric.octal
      captures:
        1: constant.numeric.prefix
      pop: true
    - match: '(0[Xx])\h+'
      scope: constant.numeric.hexadecimal
      captures:
        1: constant.numeric.prefix
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.PROPERTY.COMPUTED.entry:
    - match: '{{ANYTHING}}'
      set:
        - - meta_scope: property.computed
          - match: '\]'
            scope: delim
            pop: true
          - include: ELSE-INVALID
        - - include: EXPRESSION.ASS.entry

  EXPRESSION.STRING.DOUBLE.entry:
    # Can be entered from constant or may appear as an object literal key
    - meta_scope: string
    - meta_include_prototype: false
    - match: '\\"'
      scope: character.escape
    - match: '"'
      scope: delim
      pop: true
    - include: EXPRESSION.STRING.common.quoted

  EXPRESSION.STRING.INTERPOLATED.entry:
    # Can be entered from constant or from following identifier (tag)
    - meta_scope: string.interpolated
    - meta_include_prototype: false
    - match: '(\\\$)\{|\$(\\\{)'
      captures: character.escape
    - match: '`'
      scope: delim
      pop: true
    - match: '\$\{'
      scope: delim
      push:
        - - meta_scope: string.interpolated.expression
          - match: '\}'
            scope: delim
            pop: true
          - include: ELSE-INVALID
        - - include: EXPRESSION.ASS.entry

  EXPRESSION.STRING.SINGLE.entry:
    # Can be entered from constant or may appear as an object literal key
    - meta_scope: string
    - meta_include_prototype: false
    - match: '\\'''
      scope: character.escape
    - match: ''''
      scope: delim
      pop: true

  EXPRESSION.STRING.common:
    - match: '\\[\\bfnrtv]'
      scope: character.escape
    - match: '{{UNICODEESCAPE}}'
      scope: character.escape.unicode
    - match: '\\x\h\h'
      scope: character.escape.hexadecimal
    - match: '\\(?:[1-7][0-7]{0,2}|[0-7]{2,3})'
      scope: invalid.octal-escape
    - match: '\\0'
      scope: character.escape.null
    - match: '\\.'
      scope: pointless character.escape

  EXPRESSION.STRING.common.quoted:
    - match: '\\\n'
      scope: character.escape.newline
    - match: '\n'
      scope: invalid
      pop: true
    - include: EXPRESSION.STRING.common

# EXPRESSION & DECLARATION SHARED COMPONENTS ###################################

  CLASS.body.entry:
    - match: '\{'
      scope: delim
      set: CLASS.body.exit
    - include: ELSE-INVALID

  CLASS.body.exit:
    - match: '\}'
      scope: delim
      pop: true
    - match: ';'
      scope: pointless separator.semicolon
    # Decorator
    - match: '@'
    # Computed, numeric and string keys. These are always treated as method
    # names, despite the fact that the ES7 class properties proposal permits
    # the full range of key forms. The issue is that the decorator grammar’s
    # currently unresolved ambiguous cases are compounded by properties. Though
    # the problem lies with the decorator grammar rather than the property
    # grammar, Babel’s current solution is to only permit literal class
    # properties; we are following suit.
    - match: '\['
    - match: ''''
    - match: '"'
    - match: '(?=[\d\.])'
    # Method prefixes
    - match: 'async{{X}}'
    - match: 'get{{X}}(?!\s+\()'
    - match: 'set{{X}}(?!\s+\()'
    - match: 'static{{X}}'
    - match: '\*'
    # Note: The grammar for the ES7 class properties proposal is currently very
    # tough to pull off alongside decorators. The decorator proposal is actually
    # where the problem lies, but since Babel’s current solution is to limit the
    # grammar for property declarations to literal names, I’ve followed suit.
    - match: '{{ID}}\s*(=)'
    - match: '{{ID}}'
    - match: ELSE-INVALID
    # TODO
    # - decorator -> decorator | any below
    # - static -> any below
    # - get/set -> name -> params* -> body
    # - async -> name -> params -> body
    # - * -> name -> params -> body
    # - [ -> exp -> ] -> params -> body
    # - ' -> str-sgl -> params -> body
    # - " -> str-dbl -> params -> body
    # - \d -> num -> params -> body
    # - {{ID}} -> params -> body
    # also, do we give a shit about stupid instance props syntax? adds so many
    # complications. and we need to be careful about ensuring generalizable
    # portions (for object literal) are not constrained

  CLASS.exit:
    - meta_scope: function.class
    - meta_include_prototype: false
    - include: COMMENT
    - include: ELSE-POP

  CLASS.super-or-body:
    - match: 'extends{{ID}}'
      scope: keyword.extends
      push:
        - - include: CLASS.body.entry
        - - meta_scope: super-expression
          - include: ELSE-POP
        - - include: EXPRESSION.ASS.entry
    - include: CLASS.body.entry

  FUNCTION.body.entry:
    - meta_scope: scope.function body
    - match: '\}'
      scope: delim
      pop: true
    - include: STATEMENTS

  FUNCTION.ASYNC.exit:
    - meta_scope: function.async
    - meta_include_prototype: false
    - include: COMMENT
    - include: ELSE-POP

  FUNCTION.FUNCTION.exit:
    - meta_scope: function.function
    - meta_include_prototype: false
    - include: COMMENT
    - include: ELSE-POP

  FUNCTION.GENERATOR.exit:
    - meta_scope: function.generator
    - meta_include_prototype: false
    - include: COMMENT
    - include: ELSE-POP

  FUNCTION.PARAMETERS.entry:
    - match: '\)'
      scope: delim
      pop: true
    - match: '\['
      scope: delim
      set:
        - FUNCTION.PARAMETERS.member
        - EXPRESSION.DEFAULT-ASSIGNMENT
        - EXPRESSION.BINDING.ARRAY.exit
        - EXPRESSION.BINDING.ARRAY.entry
    - match: '\{'
      scope: delim
      set:
        - FUNCTION.PARAMETERS.member
        - EXPRESSION.DEFAULT-ASSIGNMENT
        - EXPRESSION.BINDING.OBJECT.exit
        - EXPRESSION.BINDING.OBJECT.entry
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set:
        - FUNCTION.PARAMETERS.member
        - EXPRESSION.DEFAULT-ASSIGNMENT
    - match: '\.{3}'
      scope: keyword.rest
      set:
        - match: '{{ID}}'
          captures:
            1: identifier.class
            2: identifier.general
          set:
            - match: '\)'
              scope: delim
              pop: true
            - include: ELSE-INVALID
        - include: ELSE-INVALID
    - include: ELSE-INVALID

  FUNCTION.PARAMETERS.exit:
    - meta_scope: parameters
    - include: ELSE-POP

  FUNCTION.PARAMETERS.member:
    # Note that permitting trailing comma is deliberate; this is unfortunately
    # an ES7 proposal that Babel supports (except after a rest param), and which
    # I hope dies in a fire.
    - match: ','
      scope: separator.comma
      set: FUNCTION.PARAMETERS.entry
    - match: '\)'
      scope: delim
      pop: true
    - include: ELSE-INVALID

# MODULE #######################################################################

  MODULE:
    - meta_scope: scope.module
    - include: MODULE.IMPORT
    - include: MODULE.EXPORT
    - include: MODULE.EXPORT.DECORATOR
    - include: STATEMENTS

  MODULE.IMPORT:
    - match: 'import{{X}}'
      scope: keyword.import
      set:
        - - meta_scope: statement.import
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: LINEBREAK-HERE
        - - include: MODULE.IMPORT.named-or-namespace
          - match: '{{ID}}'
            captures:
              1: module-binding identifier.class
              2: module-binding identifier.general
            set: MODULE.default-binding
          - include: MODULE.specifier

  MODULE.IMPORT.named-or-namespace:
    - match: '\{'
      scope: delim
      set: [ MODULE.from.1, MODULE.named ]
    - match: '\*'
      scope: keyword.namespace
      set: [ MODULE.from.1, MODULE.namespace ]

  MODULE.EXPORT:
    - match: 'export{{X}}'
      scope: keyword.export
      set:
        - - meta_scope: statement.export
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '\*'
            scope: keyword.namespace
            set:
              # Note: this series supports ES7 `export * as foo...`
              - - include: LINEBREAK-HERE
              - - include: MODULE.from.1
              - - match: '(?=from{{X}})'
                  pop: true
                - include: MODULE.namespace
          - match: '\{'
            scope: delim
            set: [ LINEBREAK-HERE, MODULE.from.2, MODULE.named ]
          - match: 'default{{X}}'
            scope: keyword.default-export
            set:
              # Trivia time: a default export of an unnamed function or class,
              # despite the fact that an expression is a valid default export,
              # is not an expression, but a special form of declaration that
              # looks identical to a function or class expression. Such
              # declarations *are* named -- they are named 'default'. Why
              # distinguish them if the grammar is identical? Because they don’t
              # terminate with a semicolon, and real exported expressions do.
              - include: EXPRESSION.CLASS
              - include: EXPRESSION.FUNCTION
              - match: '{{ANYTHING}}'
                set: [ LINEBREAK-HERE, EXPRESSION.ASS.entry ]
          - match: '(?=(class|const|function|let|var){{X}})'
            set: STATEMENT
          # ES7 `export foo from...`
          - match: '{{ID}}'
            captures:
              1: module-binding identifier.class
              2: module-binding identifier.general
            set: [ LINEBREAK-HERE, MODULE.from.1 ]
          - include: ELSE-INVALID

  MODULE.EXPORT.DECORATOR:
    - match: '@'
      scope: keyword.decorator

  MODULE.default-binding:
    - match: ','
      scope: separator.comma
      set:
        - include: MODULE.IMPORT.named-or-namespace
        - include: ELSE-INVALID
    - include: MODULE.from.1

  MODULE.from.1:
    - include: MODULE.from.common
    - include: ELSE-INVALID

  MODULE.from.2:
    - include: MODULE.from.common
    - include: ELSE-POP

  MODULE.from.common:
    - match: 'from{{X}}'
      scope: keyword.from
      set: MODULE.specifier

  MODULE.named:
    - meta_scope: module-names
    - match: '{{ID}}\s+(as)'
      captures:
        1: property
        2: property
        3: keyword.as
      set: MODULE.named.binding.as
    - match: '{{ID}}'
      captures:
        1: module-binding identifier.class
        2: module-binding identifier.general
      set:
        # Partial recovery rule for 'name \n as'
        - match: 'as{{X}}'
          scope: keyword.as
          set: MODULE.named.binding.as
        - match: '{{ANYTHING}}'
          set: [ MODULE.named, MODULE.named.binding ]
    - match: '\}'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  MODULE.named.binding:
    - match: ','
      scope: separator.comma
      pop: true
    - match: '(?=\})'
      pop: true
    - include: ELSE-INVALID

  MODULE.named.binding.as:
    - match: '{{ID}}'
      captures:
        1: module-binding identifier.class
        2: module-binding identifier.general
      set: [ MODULE.named, MODULE.named.binding ]
    - include: ELSE-INVALID

  MODULE.namespace:
    - match: 'as{{X}}'
      scope: keyword.as
      set:
        - match: '{{ID}}'
          captures:
            1: module-binding identifier.class
            2: module-binding identifier.general
          pop: true
        - include: ELSE-INVALID
    - include: ELSE-INVALID

  MODULE.specifier:
    - match: "'"
      scope: delim
      set: [ MODULE.specifier.exit, EXPRESSION.STRING.SINGLE.entry ]
    - match: '"'
      scope: delim
      set: [ MODULE.specifier.exit, EXPRESSION.STRING.DOUBLE.entry ]
    - include: ELSE-INVALID

  MODULE.specifier.exit:
    - meta_scope: module-specifier
    - include: ELSE-POP

# STATEMENTS ###################################################################

  STATEMENTS:
    - match: '{{ANYTHING}}'
      push: STATEMENT

  STATEMENT:
    - include: STATEMENT.BLOCK
    - include: STATEMENT.BREAK
    - include: STATEMENT.CLASS
    - include: STATEMENT.CONST-LET-VAR
    - include: STATEMENT.CONTINUE
    - include: STATEMENT.DEBUGGER
    - include: STATEMENT.DO
    - include: STATEMENT.EMPTY
    # - include: STATEMENT.FOR
    - include: STATEMENT.FUNCTION
    - include: STATEMENT.IF
    - include: STATEMENT.LABEL
    - include: STATEMENT.RETURN
    - include: STATEMENT.SWITCH
    - include: STATEMENT.TRY
    - include: STATEMENT.WHILE
    - include: STATEMENT.WITH
    - include: STATEMENT.EXPRESSION

# STATEMENT: BLOCK #############################################################

  STATEMENT.BLOCK:
    - match: '\{'
      scope: delim
      set:
        - meta_scope: scope.lexical block
        - match: '\}'
          scope: delim
          pop: true
        - include: STATEMENTS

# STATEMENT: BREAK #############################################################

  STATEMENT.BREAK:
    - match: 'break{{X}}'
      scope: keyword.break
      set:
        - - meta_scope: statement.break
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '{{ID}}'
            scope: label
            set: LINEBREAK-HERE
          - include: NO-LINEBREAK-HERE

# STATEMENT: CLASS #############################################################

  STATEMENT.CLASS:
    - match: '@'
      # TODO
    - match: 'class{{X}}'
      scope: keyword.class
      set:
        - - include: CLASS.exit
        - - match: '{{ID}}'
            captures:
              1: identifier.class
              2: identifier.general
            set: CLASS.super-or-body
          - include: ELSE-INVALID

# STATEMENT: CONST, LET & VAR ##################################################

  STATEMENT.CONST-LET-VAR:
    - match: 'const{{X}}'
      scope: keyword.const
      set:
        - - meta_scope: statement.const
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.CONST-LET-VAR.binding.entry
    - match: 'let{{X}}'
      scope: keyword.let
      set:
        - - meta_scope: statement.let
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.CONST-LET-VAR.binding.entry
    - match: 'var{{X}}'
      scope: keyword.var
      set:
        - - meta_scope: statement.var
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.CONST-LET-VAR.binding.entry

  STATEMENT.CONST-LET-VAR.binding.entry:
    - match: '\['
      scope: delim
      set:
        - - include: STATEMENT.CONST-LET-VAR.binding.exit
        - - include: STATEMENT.CONST-LET-VAR.binding.initializer
          - include: ELSE-INVALID
        - - include: EXPRESSION.BINDING.ARRAY.exit
        - - include: EXPRESSION.BINDING.ARRAY.entry
    - match: '\{'
      scope: delim
      set:
        - - include: STATEMENT.CONST-LET-VAR.binding.exit
        - - include: STATEMENT.CONST-LET-VAR.binding.initializer
          - include: ELSE-INVALID
        - - include: EXPRESSION.BINDING.OBJECT.exit
        - - include: EXPRESSION.BINDING.OBJECT.entry
    - match: '{{ID}}'
      captures:
        1: identifier.class
        2: identifier.general
      set:
        - - include: STATEMENT.CONST-LET-VAR.binding.exit
        - - include: STATEMENT.CONST-LET-VAR.binding.initializer
          - include: ELSE-POP
    - include: ELSE-INVALID

  STATEMENT.CONST-LET-VAR.binding.exit:
    - match: ','
      scope: separator.comma
      set: STATEMENT.CONST-LET-VAR.binding.entry
    - include: LINEBREAK-HERE

  STATEMENT.CONST-LET-VAR.binding.initializer:
    - match: '=(?!=)'
      scope: operator.assignment
      set: EXPRESSION.ASS.entry

# STATEMENT: CONTINUE ##########################################################

  STATEMENT.CONTINUE:
    - match: 'continue{{X}}'
      scope: keyword.continue
      set:
        - - meta_scope: statement.continue
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '{{ID}}'
            scope: label
            set: LINEBREAK-HERE
          - include: NO-LINEBREAK-HERE

# STATEMENT: DEBUGGER ##########################################################

  STATEMENT.DEBUGGER:
    - match: 'debugger{{X}}'
      scope: keyword.debugger
      set:
        - meta_scope: deprecated statement.debugger
        - include: LINEBREAK-HERE

# STATEMENT: DO ################################################################

  STATEMENT.DO:
    - match: 'do{{X}}'
      scope: keyword.do
      set:
        - - meta_scope: scope.lexical statement.do
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.condition
        - - match: 'while{{X}}'
            scope: keyword.while
            pop: true
          - include: ELSE-INVALID
        - - include: STATEMENT.statement-block-no-scope

# STATEMENT: EMPTY #############################################################

  STATEMENT.EMPTY:
    - match: ';'
      scope: statement.empty terminator
      pop: true

# STATEMENT: EXPRESSION ########################################################

  STATEMENT.EXPRESSION:
    - match: '{{ANYTHING}}'
      set:
        - - meta_scope: statement.expression
          # Special handling for ASI in expressions. We cannot break the
          # expression contexts for newlines as they can include them, yet it is
          # also true that a new statement cannot begin on the same line as an
          # unterminated expression statement. A surprisingly simple lookahead
          # lets us determine whether to pop: we can never capture a $ (children
          # are eating them), but we can look back to a ^. If we are already in
          # a position where an expression *could* terminate, the following
          # character class, appearing on a newline, is sufficient to say ‘I am
          # not part of you’.
          - match: '(?=^\s*[\{{{IDSTART}}])'
            pop: true
          - include: NO-LINEBREAK-HERE
        # The following is notably the ‘final’ case. Its ELSE-INVALID, implicit
        # in EXPRESSION.ASS.entry, which will be hit on any text at all, is the
        # one responsible for catching the majority of syntax errors.
        - - include: EXPRESSION.entry

# STATEMENT: FUNCTION ##########################################################

  STATEMENT.FUNCTION:
    - match: '(async)\s+(function){{X}}'
      captures:
        1: keyword.async
        2: keyword.function
      set:
        - FUNCTION.ASYNC.exit
        - STATEMENT.FUNCTION.entry.1
    - match: '(function)\s*(\*)'
      captures:
        1: keyword.function
        2: keyword.generator
      set:
        - FUNCTION.GENERATOR.exit
        - STATEMENT.FUNCTION.entry.1
    - match: 'function{{X}}'
      scope: keyword.function
      set:
        - FUNCTION.FUNCTION.exit
        - STATEMENT.FUNCTION.entry.2

  STATEMENT.FUNCTION.entry.1:
    - match: '{{ID}}'
      captures:
        1: name identifier.class
        2: name identifier.general
      set:
        - - match: '\{'
            scope: delim
            set: FUNCTION.body.entry
          - include: ELSE-INVALID
        - - match: '\('
            scope: delim
            set:
              - FUNCTION.PARAMETERS.exit
              - FUNCTION.PARAMETERS.entry
          - include: ELSE-INVALID
    - include: ELSE-INVALID

  STATEMENT.FUNCTION.entry.2:
    # Partial recovery context for 'function\n*'
    - match: '\*'
      scope: keyword.generator
      set: STATEMENT.FUNCTION.entry.1
    - include: STATEMENT.FUNCTION.entry.1

# STATEMENT: IF ################################################################

  STATEMENT.IF:
    - match: 'if{{X}}'
      scope: keyword.if
      set:
        - - match: 'else{{X}}'
            scope: keyword.else
            push:
              - - meta_scope: scope.lexical statement.else
                - meta_include_prototype: false
                - include: COMMENT
                - include: ELSE-POP
              - - include: STATEMENT
          - include: ELSE-POP
        - - meta_scope: scope.lexical statement.if
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.statement-block-no-scope
        - - include: STATEMENT.condition

# STATEMENT: LABEL #############################################################

  STATEMENT.LABEL:
    # Unmatchable if 'label\n:'. We do not make any attempt at recuperation in
    # this case because it would require significant additional complexity from
    # the STATEMENT.EXPRESSION context, and it’s too silly to justify that.
    - match: '{{ID}}\s*(:)'
      captures:
        1: label
        2: label
        3: separator.colon
      push:
        # The small number of items that cannot be labeled are class, const, let
        # and generator declarations. I do not know why. Babel seems to permit
        # these still, probably since it’s such an obscure thing, but it’s not
        # valid ES6 in any case.
        - match: '(?:class|const|let){{X}}|function\s*\*'
          scope: invalid
          pop: true
        - include: STATEMENT

# STATEMENT: RETURN ############################################################

  STATEMENT.RETURN:
    - match: 'return{{X}}'
      scope: keyword.return
      set:
        - - meta_scope: statement.return
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '(?=[^\s\n;])'
            set: 
              - - include: LINEBREAK-HERE
              - - include: EXPRESSION.entry
          - include: NO-LINEBREAK-HERE

# STATEMENT: SWITCH: ###########################################################

  STATEMENT.SWITCH:
    - match: 'switch{{X}}'
      scope: keyword.switch
      set:
        # Note that Babel did not take care of case-block’s lexical scoping
        # until 6.0 (not that it’s something one would often notice), but switch
        # does actually possess lexical scope.
        - - meta_scope: scope.lexical statement.switch
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '\{'
            scope: delim
            set: STATEMENT.SWITCH.case-block.1
          - include: ELSE-INVALID
        - - include: STATEMENT.condition

  STATEMENT.SWITCH.case-statements:
    - match: ':'
      scope: separator.colon
      set:
        - - match: '(?=(case|default){{X}}|\})'
            pop: true
          - include: STATEMENTS
        - - include: STATEMENT
    - include: ELSE-INVALID

  STATEMENT.SWITCH.case-block.1:
    - include: STATEMENT.SWITCH.default
    - match: 'case{{X}}'
      scope: keyword.case
      set:
        - STATEMENT.SWITCH.case-block.2
        - STATEMENT.SWITCH.case-statements
        - EXPRESSION.ASS.entry
    - include: ELSE-INVALID

  STATEMENT.SWITCH.case-block.2:
    - include: STATEMENT.SWITCH.default
    - include: STATEMENT.SWITCH.case-block.3

  STATEMENT.SWITCH.case-block.3:
    - match: 'case{{X}}'
      scope: keyword.case
      push:
        - STATEMENT.SWITCH.case-statements
        - EXPRESSION.ASS.entry
    - match: '\}'
      scope: delim
      pop: true
    - include: ELSE-INVALID

  STATEMENT.SWITCH.default:
    - match: 'default{{X}}'
      scope: keyword.case.default
      set:
        - STATEMENT.SWITCH.case-block.3
        - STATEMENT.SWITCH.case-statements

# STATEMENT: TRY ###############################################################

  STATEMENT.TRY:
    - match: 'try{{X}}'
      scope: keyword.try
      set:
        - - match: 'catch{{X}}'
            scope: keyword.catch
            set:
              - - match: 'finally{{X}}'
                  scope: keyword.finally
                  set:
                    - - meta_scope: scope.lexical statement.finally
                      - meta_include_prototype: false
                      - include: COMMENT
                      - include: ELSE-POP
                    - - include: STATEMENT.TRY.block
                - include: ELSE-POP
              - - meta_scope: scope.lexical statement.catch
                - meta_include_prototype: false
                - include: COMMENT
                - include: ELSE-POP
              - - include: STATEMENT.TRY.block
              - - match: '\('
                  scope: delim
                  set:
                    - - meta_scope: parameters.catch
                      - match: '\)'
                        scope: parameters delim
                        pop: true
                      - include: ELSE-INVALID
                    - - match: '\{'
                        scope: delim
                        set:
                          - EXPRESSION.BINDING.OBJECT.exit
                          - EXPRESSION.BINDING.OBJECT.entry
                      - match: '\['
                        scope: delim
                        set:
                          - EXPRESSION.BINDING.ARRAY.exit
                          - EXPRESSION.BINDING.ARRAY.entry
                      - match: '{{ID}}'
                        captures:
                          1: identifier.class
                          2: identifier.general
                        pop: true
                      - include: ELSE-INVALID
                - include: ELSE-INVALID
          - include: ELSE-INVALID
        - - meta_scope: scope.lexical statement.try
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.TRY.block

  STATEMENT.TRY.block:
    - match: '\{'
      scope: delim
      set:
        - match: '\}'
          scope: delim
          pop: true
        - include: STATEMENTS

# STATEMENT: WITH ##############################################################

  STATEMENT.WITH:
    - match: 'with{{X}}'
      scope: keyword.with
      set:
        - - meta_scope: deprecated scope.lexical.with statement.with
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.statement-block-no-scope
        - - include: STATEMENT.condition

# STATEMENT: WHILE #############################################################

  STATEMENT.WHILE:
    - match: 'while{{X}}'
      scope: keyword.while
      set:
        - - meta_scope: scope.lexical statement.while
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - include: STATEMENT.statement-block-no-scope
        - - include: STATEMENT.condition

# STATEMENT COMPONENTS #########################################################

  STATEMENT.condition:
    - match: '\('
      scope: delim
      set:
        - - meta_scope: condition
          - match: '\)'
            pop: true
          - include: ELSE-INVALID
        - - include: EXPRESSION.entry
    - include: ELSE-INVALID

  STATEMENT.statement-block-no-scope:
    # This is used as a component of control statements that create a scope and
    # include a single statement. That statement is frequently a block, in which
    # case we don’t want to double our ‘scope’ scopes.
    - match: '\{'
      scope: delim
      set:
        - meta_scope: block
        - match: '\}'
          scope: delim
          pop: true
        - include: STATEMENTS
    - include: STATEMENT
