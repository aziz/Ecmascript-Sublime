%YAML 1.2
---
name: Ecmascript Scoped
file_extensions: [ js, es, es6 ]
scope: source.es

# This is a special variation that takes a very different approach. In the
# normal ES Sublime definition, we take great care to avoid depth on the context
# stack, because a syntax error could cause a cascade of mis-scoping that we’d
# prefer to finesse our way out of. Here we use the context stack as intended,
# which will lead to some very interesting effects. Specifically, it enables us
# to create themes that highlight on *depth of scope* (that is, JS scope)...

# This is really just an experiment right now, and as part of the experiment, I
# have used non-standard scope naming. Instead of long hierarchical strings, it
# leverages the natural hierarchy so that scopes can be targeted ‘organically’.

# In other words, you would not target this:
#  `punctuation.definition.comment`
#
# But rather:
#  `comment delimiter`
#
# If this works out, I wonder if we couldn’t begin developing new conventions
# that really take advantage of this better syntax tool...?
#
# Below, matches marked NEWLINE ALERT signal cases where sublime-syntax is not
# enough to resolve ambiguities if a newline is found in an unfortunate place.

variables:

# CHARACTER CLASSES ############################################################

  IDSTARTOTHER: '℘℮゛゜'
  IDSTART: '\p{L}\p{Nl}{{IDSTARTOTHER}}'
  IDCONTINUEOTHER: '··፩-፱᧚'
  IDCONTINUE: '{{IDSTART}}\p{Mn}\p{Mc}\p{Nd}\p{Pc}{{IDCONTINUEOTHER}}'

# BOUNDARY MATCHES #############################################################

  ANYTHING: '(?=[\S\s])'
  X: '(?=[^\$_‍‍{{IDCONTINUE}}]|$)'

# IDENTIFIERS ##################################################################

  UNICODEESCAPE: '\\u(?:\h{4}|\{\h+\})'
  RESERVED: 'await|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:e(?:bugger|fault|lete)|o)|e(?:lse|num|x(?:port|tends))|f(?:alse|inally|or|unction)|i(?:f|mp(?:lements|ort)|n(?:stanceof|terface)?)|Infinity|let|NaN|n(?:ew|ull)|p(?:ackage|r(?:ivate|otected)|ublic)|return|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y)|ypeof)|undefined|v(?:ar|oid)|w(?:hile|ith)|yield'
  IDPART:  '(?:[\$_‍‍{{IDCONTINUE}}]|{{UNICODEESCAPE}})*'
  IDCAP: '(\p{Lu}{{IDPART}})'
  IDGEN: '([{{IDSTART}}]{{IDPART}})'
  IDPROP: '{{IDCAP}}|{{IDGEN}}'
  ID: '(?!(?:{{RESERVED}})[^\$_‍‍{{IDCONTINUE}}])(?<![{{IDCONTINUE}}])(?:{{IDCAP}}|{{IDGEN}})'

################################################################################
################################################################################

contexts:

# ASSISTS ######################################################################

  ELSE-INVALID:
    - match: '{{IDGEN}}|.'
      scope: invalid

  ELSE-POP:
    - match: '{{ANYTHING}}'
      pop: true

  NO-LINEBREAK-HERE:
    # Pop on newline or semicolon; else invalid
    - match: '$'
      pop: true
    - match: ';'
      scope: terminator
      pop: true
    - include: ELSE-INVALID

  LINEBREAK-HERE:
    # Pop on semicolon; else invalid. But, if a newline is encountered first,
    # pop on semicolon, or else just pop.
    - match: ';'
      scope: terminator
      pop: true
    - match: '$'
      set:
        - match: ';'
          scope: terminator
          pop: true
        - include: ELSE-POP
    - include: ELSE-INVALID

# ENTRY ########################################################################

  main:
    - meta_include_prototype: false
    - match: '^\#\!.*'
      scope: directive.shebang
      push: MODULE
    - match: '{{ANYTHING}}'
      push: MODULE

# PROTOTYPE ####################################################################

  prototype:
    - match: '\s+'
    - include: COMMENT

################################################################################
################################################################################

# COMMENT ######################################################################

  COMMENT:
    - include: COMMENT.BLOCK
    - include: COMMENT.LINE

  COMMENT.BLOCK:
    - match: '\/\*'
      scope: delim
      push:
        - meta_scope: comment
        - match: '\*\/'
          scope: delim
          pop: true

  COMMENT.LINE:
    - match: '\/\/'
      scope: delim
      push:
        - meta_scope: comment
        - match: '$'
          pop: true

# EXPRESSION ###################################################################

  EXPRESSION.entry:
    - match: '{{ANYTHING}}'
      set: [ EXPRESSION.exit, EXPRESSION.ASS.entry ]

  EXPRESSION.exit:
    - match: ','
      scope: operator.comma
      push: EXPRESSION.ASS.entry
    - include: ELSE-POP

  EXPRESSION.ASS.entry:
    - include: EXPRESSION.ASS.common
    - include: ELSE-INVALID

  EXPRESSION.ASS.common:
    # Simpler, unambiguous token matches first:
    - include: EXPRESSION.UNARY
    - include: EXPRESSION.CLASS
    - include: EXPRESSION.FUNCTION
    - include: EXPRESSION.DO
    - include: EXPRESSION.CONSTANT
    - include: EXPRESSION.REFERENCE
    # Bracket-initialized
    - include: EXPRESSION.COMPREHENSION.ARRAY
    - include: EXPRESSION.BINDING.ARRAY
    - include: EXPRESSION.LITERAL.ARRAY
    # Brace-initialized
    - include: EXPRESSION.BINDING.OBJECT
    - include: EXPRESSION.LITERAL.OBJECT
    # Paren-initialized
    - include: EXPRESSION.ARROW
    - include: EXPRESSION.COMPREHENSION.GENERATOR
    - include: EXPRESSION.PARENTHETICAL

  # Four exits (plus two special cases): these alternate exit cases (and note,
  # each is inclusive of its predecessors) are our half-assed way of following,
  # to a limited extent, some of the grammatical constraints of expression
  # formation. Since the grammatical designation of an expression (component) is
  # generally out of reach for us with linear matches, the best we can do is say
  # ‘the following are plausible continuations after X was encountered’. Though
  # it is hardly strict, and will permit plenty of malformed constructs that
  # ought to be detectable at this level, it is adequate for ensuring
  # unambiguous matching generally and reducing the number of nonsensical match
  # attempts on exiting various contexts.

  # OPERABLE
  # The AE thus far is not accessible, invocable, or assignable. This, on its
  # own, occurs only after postfix operators, undefined and null. (Though,
  # technically, assigning to undefined will not throw, I am willing to collect
  # that here as it is nonsensical legacy pollution from when undefined was
  # still a redefinable native variable; plus, accessing it is an error, so to
  # support this unusual and useless case would necessitate a totally different
  # exit structure.)
  EXPRESSION.ASS.exit.1:
    - match: '\?'
      scope: operator.logical
      set:
        - EXPRESSION.ASS.ENTRY
        - - match: ':'
            scope: operator.logical
            pop: true
          - include: ELSE-INVALID
        - EXPRESSION.ASS.entry
    - match: '(?:[\+\-\/%]|\*{2})(?!=)'
      scope: operator.arithmetical
      set: EXPRESSION.ASS.entry
    # This special series of lookaheads is one of the (imperfect) approaches we
    # need to employ to prevent method decorator expressions from eating the
    # method itself. In this case, the issue is that the previously unambiguous
    # generator star, which can prefix a method name, could as easily be an
    # infix multiplication operator. The checks are:
    # 1. that it is not an arithmetical assignment
    # 2. that it is not a generator star with a double-quoted method name
    # 3. that it is not a generator star with a single-quoted method name
    # 4. that it is not a generator star with a computed method name
    # 5. that it is not a generator star with a literal method name
    # All of these checks can easily fail, irrecoverably, if a linebreak occurs
    # in an unfortunate position; and in the case of a computed property, it
    # will also fail if the accessor expression includes brackets; and in the
    # case of a regular method name, it is both extra sensitive to line breaks
    # and fails if the arguments contain parens (in default values).
    - match: >-
        (?x)
          \*
          (?! [=\*])
          (?! \s* " [^"]+ " \s* \( )
          (?! \s* '' [^'']+ '' \s* \( )
          (?! \s* \[ [^\]]+ \] \s* \( )
          (?! \s* {{IDGEN}} \s* \([^)]*\) \s* \{)
      scope: operator.arithmetical
      set: EXPRESSION.ASS.entry
    - match: '[!=]==?|[<>]=|instanceof{{X}}|in{{X}}'
      scope: operator.relational
      set: EXPRESSION.ASS.entry
    - match: '&&|\|\|(?!=)'
      scope: operator.logical
      set: EXPRESSION.ASS.entry
    - match: '(?:[&\|\^]|<<|>>>?)(?!=)'
      scope: operator.bitwise
      set: EXPRESSION.ASS.entry
    # The bind operator is one of a number of cases where, although the grammar
    # is quite lucid, we leave things more open ended than they are in reality
    # for the sake of reducing the complexity of the grammar (and I am unsure if
    # it is even possible to model expression components like ‘NewExpression’ in
    # sublime-syntax with much success).
    - match: '::'
      scope: operator.evaluative
      scope: EXPRESSION.ASS.entry
    - include: ELSE-POP

  # ACCESSIBLE, OPERABLE
  # The AE thus far is not invocable or assignable. This, on its own, occurs
  # after constants and literals.
  EXPRESSION.ASS.exit.2:
    - match: '\.'
      scope: operator.accessor
      set:
        - match: 'prototype{{X}}'
          scope: property prototype
          set: EXPRESSION.exit.4
        - match: '__proto__{{X}}'
          scope: property proto
          set: EXPRESSION.exit.4
        # We attempt to capture invocation/instantiation here, and the call
        # scope will then be inclusive of the identifier. This can be broken
        # by linebreaks, though it will not otherwise be disruptive.
        - match: '{{IDPROP}}\s*(\()'
          captures:
            1: identifier.class
            2: identifier.general
            3: arguments delim
          set: [ EXPRESSION.exit.3, EXPRESSION.ARGUMENTS.entry ]
        - match: '{{IDPROP}}'
          scope: property
          captures:
            1: identifier.class
            2: identifier.general
          set: EXPRESSION.exit.4
        - include: ELSE-INVALID
    # Prevent decorator expressions from eating computed properties, hopefully.
    # This is a sloppy patch for a defect in the proposed grammar.
    - match: >-
        (?x) (?=
          \[
            [^\[\]]+
          \]
          \s* \( [^\)]* \) \s* \{
        )
      pop: true
    - match: '\['
      scope: delim
      set:
        - EXPRESSION.ASS.exit.4
        - - meta_scope: property
          - match: '\]'
            scope: delim
            pop: true
          - include: ELSE-INVALID
        - EXPRESSION.ASS.entry
    - include: EXPRESSION.ASS.exit.1

  # INVOCABLE, ACCESSIBLE, OPERABLE
  # That is, any value except an identifier or property reference. In reality,
  # it is of course unknown whether such expressions are truly invocable, only
  # that it cannot be ruled out.
  EXPRESSION.ASS.exit.3:
    - match: '\('
      scope: arguments delim
      set: [ EXPRESSION.exit.3, EXPRESSION.ARGUMENTS.entry ]
    - match: '`'
      scope: delim
      set: [ EXPRESSION.exit.2, EXPRESSION.STRING.INTERPOLATED.entry ]
    - include: EXPRESSION.ASS.exit.2

  # ASSIGNABLE, INVOCABLE, ACCESSIBLE, OPERABLE
  # That is, identifiers, including properties
  EXPRESSION.ASS.exit.4:
    - match: '=(?!=)'
      scope: operator.assignment
      set: EXPRESSION.ASS.entry
    - match: '(?:[\+\-\/%]|\*{1,2})='
      scope: operator.assignment.arithmetical
      set: EXPRESSION.ASS.entry
    # This existed in Babel at one point, but I’m not sure if it stuck around
    - match: '\|\|='
      scope: operator.assignment.mallet
      set: EXPRESSION.ASS.entry
    - match: '(?:[&\^\|]|<<|>>>?)='
      scope: operator.assignment.bitwise
    # We match the newline here to ‘skip’ postfix ops in that case
    - match: '$'
      set: EXPRESSION.ASS.exit.3
    - match: '\+\+|\-\-'
      scope: operator.assignment.arithmetical.postfix
      set: EXPRESSION.ASS.exit.1
    - include: EXPRESSION.ASS.exit.3

  # SPECIAL: AMBIGUOUS SINGLE IDENTIFIER TRAP
  # The AE thus far is as #4, but is conceivably the argument of an arrow
  # function with an obnoxiously placed linebreak
  EXPRESSION.ASS.exit.5:
    - match: '=>'
      scope: keyword.function.arrow
    - include: EXPRESSION.ASS.exit.4

  # SPECIAL: AMBIGUOUS OBJECT/ARRAY LITERAL TRAP
  # The AE thus far is as #2, but is conceivably the binding pattern of an
  # assignment with an obnoxiously placed linebreak
  EXPRESSION.ASS.exit.6:
    - match: '=(?!=)'
      scope: operator.assignment
    - include: EXPRESSION.ASS.exit.2

# EXPRESSION: ARROW ############################################################

  EXPRESSION.ARROW:

# EXPRESSION: BINDING PATTERNS #################################################

  EXPRESSION.BINDING.ARRAY:
  EXPRESSION.BINDING.OBJECT:

# EXPRESSION: COMPREHENSIONS ###################################################

  EXPRESSION.COMPREHENSION.ARRAY:
  EXPRESSION.COMPREHENSION.GENERATOR:

# EXPRESSION: CONSTANTS ########################################################

  EXPRESSION.CONSTANT:
    - match: '(?:NaN|Infinity){{X}}'
      scope: constant.numeric.abstract
      set: EXPRESSION.ASS.exit.2
    - match: '(?:true|false){{X}}'
      scope: constant.boolean
      set: EXPRESSION.ASS.exit.2
    - match: 'null{{X}}'
      scope: constant.null
      set: EXPRESSION.ASS.exit.1
    - match: 'undefined{{X}}'
      scope: constant.undefined
      set: EXPRESSION.ASS.exit.1
    - match: '(?=[\d\.])'
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.NUMBER.entry ]
    - match: "'"
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.SINGLE.entry ]
    - match: '"'
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.DOUBLE.entry ]
    - match: '`'
      scope: delim
      set: [ EXPRESSION.ASS.exit.2, EXPRESSION.STRING.INTERPOLATED.entry ]

# EXPRESSION: FUNCTIONS ########################################################

  EXPRESSION.DO:
  EXPRESSION.CLASS:
  EXPRESSION.FUNCTION:

# EXPRESSION: LITERAL: ARRAY ###################################################

  EXPRESSION.LITERAL.ARRAY:

# EXPRESSION: LITERAL: OBJECT ##################################################

  EXPRESSION.LITERAL.OBJECT:

# EXPRESSION: PARENTHETICAL ####################################################

  EXPRESSION.PARENTHETICAL:

# EXPRESSION: REFERENCE ########################################################

  EXPRESSION.REFERENCE:

# EXPRESSION: UNARY PREFIX OPERATORS ###########################################

  EXPRESSION.UNARY:
    - match: '(?:delete|typeof|void|::){{X}}'
      scope: operator.evaluative
    - match: '\+\+|\-\-'

# EXPRESSION: SHARED COMPONENTS ################################################

  EXPRESSION.ARGUMENTS.entry:
    - meta_scope: invocation
    - meta_content_scope: arguments
    - match: '\)'
      scope: arguments delim
      pop: true

  EXPRESSION.NUMBER.entry:
    # Can be entered from constant or may appear as an object literal key
    # Enterability (on lookahead) prevents the need for duplication
    - match: >-
        (?x)
          (?:
            0 (?: \. \d* )? |
            [1-9]\d* (?: \. \d* )? |
            \. \d+
          )
          ( [Ee] [\+\-]? \d+ )?
          {{X}}
      scope: constant.numeric.decimal
      captures:
        1: constant.numeric.exponent
      pop: true
    - match: '(0[Bb])[01]+'
      scope: constant.numeric.binary
      captures:
        1: constant.numeric.prefix
      pop: true
    - match: '(0[Oo])[0-7]+'
      scope: constant.numeric.octal
      captures:
        1: constant.numeric.prefix
      pop: true
    - match: '(0[Xx])\h+'
      scope: constant.numeric.hexadecimal
      captures:
        1: constant.numeric.prefix
      pop: true
    - include: ELSE-INVALID

  EXPRESSION.STRING.DOUBLE.entry:
    # Can be entered from constant or may appear as an object literal key

  EXPRESSION.STRING.INTERPOLATED.entry:
    # Can be entered from constant or from following identifier (tag)
    - meta_scope: string.interpolated

  EXPRESSION.STRING.SINGLE.entry:
    # Can be entered from constant or may appear as an object literal key

# MODULE #######################################################################

  MODULE:
    - meta_scope: scope.module
    - include: MODULE.IMPORT
    - include: MODULE.EXPORT
    - include: MODULE.EXPORT.DECORATOR
    - include: STATEMENT

  MODULE.IMPORT:
    - match: 'import{{X}}'
      scope: keyword.import

  MODULE.EXPORT:
    - match: 'export{{X}}'
      scope: keyword.export

  MODULE.EXPORT.DECORATOR:
    - match: '@'
      scope: keyword.decorator

# STATEMENTS ###################################################################

  STATEMENT:
    - include: STATEMENT.BLOCK
    - include: STATEMENT.BREAK
    # - include: STATEMENT.CLASS
    # - include: STATEMENT.CONST
    - include: STATEMENT.CONTINUE
    - include: STATEMENT.DEBUGGER
    # - include: STATEMENT.DO
    - include: STATEMENT.EMPTY
    # - include: STATEMENT.FOR
    # - include: STATEMENT.FUNCTION
    # - include: STATEMENT.IF
    # - include: STATEMENT.LET
    - include: STATEMENT.RETURN
    # - include: STATEMENT.SWITCH
    # - include: STATEMENT.TRY
    # - include: STATEMENT.VAR
    # - include: STATEMENT.WHILE
    - include: STATEMENT.WITH
    # - include: STATEMENT.EXPRESSION

# STATEMENT: BLOCK #############################################################

  STATEMENT.BLOCK:
    - match: '\{'
      scope: delim
      push:
        - meta_scope: scope.lexical block
        - match: '\}'
          scope: delim
          pop: true
        - include: STATEMENT

# STATEMENT: BREAK #############################################################

  STATEMENT.BREAK:
    - match: 'break{{X}}'
      scope: keyword.break
      push:
        - - meta_scope: statement.break
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '{{ID}}'
            scope: label
            set: LINEBREAK-HERE
          - include: NO-LINEBREAK-HERE

# STATEMENT: CONTINUE ##########################################################

  STATEMENT.CONTINUE:
    - match: 'continue{{X}}'
      scope: keyword.continue
      push:
        - - meta_scope: statement.continue
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '{{ID}}'
            scope: label
            set: LINEBREAK-HERE
          - include: NO-LINEBREAK-HERE

# STATEMENT: DEBUGGER ##########################################################

  STATEMENT.DEBUGGER:
    - match: 'debugger{{X}}'
      scope: keyword.debugger
      push:
        - meta_scope: statement.debugger
        - include: LINEBREAK-HERE

# STATEMENT: EMPTY #############################################################

  STATEMENT.EMPTY:
    - match: ';'
      scope: statement.empty terminator

# STATEMENT: RETURN ############################################################

  STATEMENT.RETURN:
    - match: 'return{{X}}'
      scope: keyword.return
      push:
        - - meta_scope: statement.return
          - meta_include_prototype: false
          - include: COMMENT
          - include: ELSE-POP
        - - match: '(?=[^\s\n;])'
            set: 
              - - include: LINEBREAK-HERE
              - - include: EXPRESSION.entry
          - include: NO-LINEBREAK-HERE